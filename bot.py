from pyrogram import Client, filters
from pyrogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton, CallbackQuery
from pymongo import MongoClient, ASCENDING
from flask import Flask
from threading import Thread
import os
import re
from datetime import datetime, timedelta # timedelta ржЗржорзНржкрзЛрж░рзНржЯ ржХрж░рж╛ рж╣ржпрж╝рзЗржЫрзЗ
import asyncio
import urllib.parse

# --- Configs ---
API_ID = int(os.getenv("API_ID"))
API_HASH = os.getenv("API_HASH")
BOT_TOKEN = os.getenv("BOT_TOKEN")
CHANNEL_ID = int(os.getenv("CHANNEL_ID"))
RESULTS_COUNT = int(os.getenv("RESULTS_COUNT", 10))
ADMIN_IDS = list(map(int, os.getenv("ADMIN_IDS", "").split(",")))
DATABASE_URL = os.getenv("DATABASE_URL")
UPDATE_CHANNEL = os.getenv("UPDATE_CHANNEL", "https://t.me/CTGMovieOfficial")
START_PIC = os.getenv("START_PIC", "https://i.ibb.co/prnGXMr3/photo-2025-05-16-05-15-45-7504908428624527364.jpg")

# Bitly API Token (ржпржжрж┐ ржЖржкржирж┐ Bitly ржмрзНржпржмрж╣рж╛рж░ ржХрж░рждрзЗ ржЪрж╛ржи, ржЖржкржирж╛рж░ .env ржлрж╛ржЗрж▓рзЗ BITLY_API_TOKEN ржпрзЛржЧ ржХрж░рзБржи)
BITLY_API_TOKEN = os.getenv("BITLY_API_TOKEN")

app = Client("movie_bot", api_id=API_ID, api_hash=API_HASH, bot_token=BOT_TOKEN)

# --- MongoDB setup ---
mongo = MongoClient(DATABASE_URL)
db = mongo["movie_bot"]
movies_col = db["movies"]
feedback_col = db["feedback"]
stats_col = db["stats"]
users_col = db["users"] # ржЗржЙржЬрж╛рж░ ржХрж╛рж▓рзЗржХрж╢ржи
settings_col = db["settings"]

# Index
movies_col.create_index([("title", ASCENDING)])
movies_col.create_index("message_id")
movies_col.create_index("language")

# --- Flask ---
flask_app = Flask(__name__)
@flask_app.route("/")
def home():
    return "Bot is running!"
Thread(target=lambda: flask_app.run(host="0.0.0.0", port=8080)).start()

# --- Helpers ---
def clean_text(text):
    return re.sub(r'[^a-zA-Z0-9]', '', text.lower())

def extract_year(text):
    match = re.search(r"(19|20)\d{2}", text)
    return match.group() if match else None

def extract_language(text):
    langs = ["Bengali", "Hindi", "English"]
    return next((lang for lang in langs if lang.lower() in text.lower()), "Unknown")

async def delete_message_later(chat_id, message_id, delay=600): # ржбрж┐ржлрж▓рзНржЯ ржбрж┐рж▓рзЗ 10 ржорж┐ржирж┐ржЯ
    await asyncio.sleep(delay)
    try:
        await app.delete_messages(chat_id, message_id)
    except Exception as e:
        print(f"Error deleting message {message_id} in chat {chat_id}: {e}")

# --- рж▓рж┐ржЩрзНржХ рж╢рж░рзНржЯржирж╛рж░ ржлрж╛ржВрж╢ржи ---
# ржПржЯрж┐ ржПржХржЯрж┐ ржбрж╛ржорж┐ ржлрж╛ржВрж╢ржиред ржЖржкржирж╛ржХрзЗ ржЖржкржирж╛рж░ ржкржЫржирзНржжрзЗрж░ рж▓рж┐ржЩрзНржХ рж╢рж░рзНржЯржирж╛рж░ рж╕рж╛рж░рзНржнрж┐рж╕рзЗрж░ API ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ ржПржЯрж┐ рждрзИрж░рж┐ ржХрж░рждрзЗ рж╣ржмрзЗред
# Bitly ржмрзНржпржмрж╣рж╛рж░ ржХрж░рждрзЗ ржЪрж╛ржЗрж▓рзЗ, BITLY_API_TOKEN рж╕рзЗржЯ ржХрж░рзБржи ржПржмржВ Bitly API ржХрж▓ рж▓ржЬрж┐ржХ ржпрзЛржЧ ржХрж░рзБржиред
def shorten_link(long_url):
    """
    ржПржЗ ржлрж╛ржВрж╢ржиржЯрж┐ ржПржХржЯрж┐ рж▓ржорзНржмрж╛ URL ржХрзЗ рж╢рж░рзНржЯ ржХрж░рзЗред
    ржЖржкржирж╛рж░ ржкржЫржирзНржжрзЗрж░ рж▓рж┐ржЩрзНржХ рж╢рж░рзНржЯржирж╛рж░ рж╕рж╛рж░рзНржнрж┐рж╕рзЗрж░ API ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ ржПржЯрж┐ ржЗржоржкрзНрж▓рж┐ржорзЗржирзНржЯ ржХрж░рзБржиред
    ржЙржжрж╛рж╣рж░ржгрж╕рзНржмрж░рзВржк, Bitly API ржмрзНржпржмрж╣рж╛рж░ ржХрж░рж╛ ржпрзЗрждрзЗ ржкрж╛рж░рзЗред
    """
    if BITLY_API_TOKEN:
        # Bitly API ржЗржирзНржЯрж┐ржЧрзНрж░рзЗрж╢ржи (ржЙржжрж╛рж╣рж░ржг)
        import requests
        headers = {
            "Authorization": f"Bearer {BITLY_API_TOKEN}",
            "Content-Type": "application/json"
        }
        payload = {
            "long_url": long_url
        }
        try:
            response = requests.post("https://api-ssl.bitly.com/v4/shorten", headers=headers, json=payload)
            response.raise_for_status()
            short_url = response.json().get("link")
            if short_url:
                print(f"Shortened {long_url} to {short_url}")
                return short_url
        except requests.exceptions.RequestException as e:
            print(f"Error shortening link with Bitly: {e}")
            # рждрзНрж░рзБржЯрж┐ рж╣рж▓рзЗржУ ржорзВрж▓ рж▓рж┐ржЩрзНржХржЯрж┐ ржлрзЗрж░ржд ржжрж┐ржи
            return long_url
    
    # ржпржжрж┐ ржХрзЛржирзЛ рж▓рж┐ржЩрзНржХ рж╢рж░рзНржЯржирж╛рж░ API рж╕рзЗржЯ ржирж╛ ржерж╛ржХрзЗ ржмрж╛ ржмрзНржпрж░рзНрже рж╣ржпрж╝, рждрж╛рж╣рж▓рзЗ ржорзВрж▓ рж▓рж┐ржЩрзНржХржЯрж┐ ржлрзЗрж░ржд ржжрж┐ржи
    print(f"No link shortener configured or failed for {long_url}. Returning original URL.")
    return long_url

# --- ржкрзНрж░рж┐ржорж┐ржпрж╝рж╛ржо ржЗржЙржЬрж╛рж░ ржЪрзЗржХ ржлрж╛ржВрж╢ржи ---
def is_premium_user(user_id):
    user = users_col.find_one({"_id": user_id})
    if user and user.get("is_premium") and user.get("premium_until") and user["premium_until"] > datetime.utcnow():
        return True
    return False

# --- Handlers ---

@app.on_message(filters.chat(CHANNEL_ID))
async def save_post(_, msg: Message):
    text = msg.text or msg.caption
    if not text:
        return
    movie = {
        "message_id": msg.id,
        "title": text,
        "date": msg.date,
        "year": extract_year(text),
        "language": extract_language(text),
        "title_clean": clean_text(text)
    }
    movies_col.update_one({"message_id": msg.id}, {"$set": movie}, upsert=True)

    setting = settings_col.find_one({"key": "global_notify"})
    if setting and setting.get("value"):
        # ржкрзНрж░рж┐ржорж┐ржпрж╝рж╛ржо ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзАржжрзЗрж░ ржХрж╛ржЫрзЗ ржирзЛржЯрж┐ржлрж┐ржХрзЗрж╢ржи ржкрж╛ржарж╛рждрзЗ ржкрж╛рж░рзЗржи, ржЕржержмрж╛ ржирждрзБржи ржорзБржнрж┐ ржЖржкрж▓рзЛржб рж╣рж▓рзЗ ржЬрж╛ржирж╛рждрзЗ ржкрж╛рж░рзЗржи
        # ржПржЦржи рж╕ржм ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзАрж░ ржХрж╛ржЫрзЗржЗ ржирзЛржЯрж┐ржлрж┐ржХрзЗрж╢ржи ржпрж╛ржмрзЗ, ржпржжрж┐ 'notify' False ржирж╛ рж╣ржпрж╝
        for user in users_col.find({"notify": {"$ne": False}}):
            try:
                # рж╕ржВржХрзНрж╖рж┐ржкрзНржд ржирзЛржЯрж┐ржлрж┐ржХрзЗрж╢ржи
                first_line = text.splitlines()[0]
                notification_text = f"ржирждрзБржи ржорзБржнрж┐ ржЖржкрж▓рзЛржб рж╣ржпрж╝рзЗржЫрзЗ: **{first_line[:100]}**\nржПржЦржиржЗ рж╕рж╛рж░рзНржЪ ржХрж░рзЗ ржжрзЗржЦрзБржи!"
                await app.send_message(user["_id"], notification_text)
            except Exception as e:
                print(f"Could not send notification to user {user.get('_id', 'N/A')}: {e}")

@app.on_message(filters.command("start"))
async def start(_, msg: Message):
    users_col.update_one(
        {"_id": msg.from_user.id},
        {"$set": {"joined": datetime.utcnow()}},
        upsert=True
    )
    btns = InlineKeyboardMarkup([
        [InlineKeyboardButton("ржЖржкржбрзЗржЯ ржЪрзНржпрж╛ржирзЗрж▓", url=UPDATE_CHANNEL)],
        [InlineKeyboardButton("ржЕрзНржпрж╛ржбржорж┐ржирзЗрж░ рж╕рж╛ржерзЗ ржпрзЛржЧрж╛ржпрзЛржЧ", url="https://t.me/ctgmovies23")],
        [InlineKeyboardButton("ржЖржорж╛ржжрзЗрж░ ржкрзНрж░рж┐ржорж┐ржпрж╝рж╛ржо ржирж┐ржи!", callback_data="show_premium_info")] # ржкрзНрж░рж┐ржорж┐ржпрж╝рж╛ржо ржЗржиржлрзЛ ржмрж╛ржЯржи
    ])
    m = await msg.reply_photo(photo=START_PIC, caption="ржЖржорж╛ржХрзЗ ржорзБржнрж┐рж░ ржирж╛ржо ржкрж╛ржарж╛ржи рж╕рж╛рж░рзНржЪ ржХрж░рж╛рж░ ржЬржирзНржпред", reply_markup=btns)
    asyncio.create_task(delete_message_later(m.chat.id, m.id, delay=1200)) # 20 ржорж┐ржирж┐ржЯ ржкрж░ ржбрж┐рж▓рж┐ржЯ рж╣ржмрзЗ

@app.on_message(filters.command("feedback") & filters.private)
async def feedback(_, msg):
    if len(msg.command) < 2:
        return await msg.reply("ржЕржирзБржЧрзНрж░рж╣ ржХрж░рзЗ `/feedback` ржПрж░ ржкрж░ ржЖржкржирж╛рж░ ржорждрж╛ржоржд рж▓рж┐ржЦрзБржиред")
    feedback_col.insert_one({
        "user_id": msg.from_user.id,
        "username": msg.from_user.username,
        "first_name": msg.from_user.first_name,
        "text": msg.text.split(None, 1)[1],
        "time": datetime.utcnow()
    })
    m = await msg.reply("ржЖржкржирж╛рж░ ржорзВрж▓рзНржпржмрж╛ржи ржорждрж╛ржорждрзЗрж░ ржЬржирзНржп ржзржирзНржпржмрж╛ржж! ЁЯТЦ")
    asyncio.create_task(delete_message_later(m.chat.id, m.id, delay=120)) # 2 ржорж┐ржирж┐ржЯ ржкрж░ ржбрж┐рж▓рж┐ржЯ рж╣ржмрзЗ

@app.on_message(filters.command("broadcast") & filters.user(ADMIN_IDS))
async def broadcast(_, msg):
    if len(msg.command) < 2:
        return await msg.reply("ржмрзНржпржмрж╣рж╛рж░: `/broadcast ржЖржкржирж╛рж░ ржорзЗрж╕рзЗржЬ`")
    broadcast_message = msg.text.split(None, 1)[1]
    count = 0
    failed_count = 0
    for user in users_col.find():
        try:
            await app.send_message(user["_id"], broadcast_message)
            count += 1
            await asyncio.sleep(0.1) # Flood wait ржПржбрж╝рж╛ржирзЛрж░ ржЬржирзНржп ржЫрзЛржЯ ржбрж┐рж▓рзЗ
        except Exception as e:
            failed_count += 1
            print(f"Failed to send broadcast to user {user.get('_id', 'N/A')}: {e}")
    await msg.reply(f"ржмрзНрж░ржбржХрж╛рж╕рзНржЯ ржкрж╛ржарж╛ржирзЛ рж╣ржпрж╝рзЗржЫрзЗ **{count}** ржЬржи ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзАржХрзЗред **{failed_count}** ржЬржи ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзАрж░ ржХрж╛ржЫрзЗ ржкрзМржБржЫрж╛ржирзЛ ржпрж╛ржпрж╝ржирж┐ред")

@app.on_message(filters.command("stats") & filters.user(ADMIN_IDS))
async def stats(_, msg):
    total_users = users_col.count_documents({})
    premium_users = users_col.count_documents({"is_premium": True, "premium_until": {"$gt": datetime.utcnow()}})
    await msg.reply(
        f"**ржмржЯ ржкрж░рж┐рж╕ржВржЦрзНржпрж╛ржи:**\n"
        f"ржорзЛржЯ ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзА: `{total_users}`\n"
        f"ржкрзНрж░рж┐ржорж┐ржпрж╝рж╛ржо ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзА: `{premium_users}`\n"
        f"ржорзЛржЯ ржорзБржнрж┐: `{movies_col.count_documents({})}`\n"
        f"ржорзЛржЯ ржлрж┐ржбржмрзНржпрж╛ржХ: `{feedback_col.count_documents({})}`"
    )

@app.on_message(filters.command("notify") & filters.user(ADMIN_IDS))
async def notify_command(_, msg: Message):
    if len(msg.command) != 2 or msg.command[1] not in ["on", "off"]:
        return await msg.reply("ржмрзНржпржмрж╣рж╛рж░: `/notify on` ржЕржержмрж╛ `/notify off`")
    new_value = True if msg.command[1] == "on" else False
    settings_col.update_one(
        {"key": "global_notify"},
        {"$set": {"value": new_value}},
        upsert=True
    )
    status = "рж╕ржХрзНрж░рж┐ржпрж╝" if new_value else "ржирж┐рж╖рзНржХрзНрж░рж┐ржпрж╝"
    await msg.reply(f"тЬЕ ржЧрзНрж▓рзЛржмрж╛рж▓ ржирзЛржЯрж┐ржлрж┐ржХрзЗрж╢ржи **{status}** ржХрж░рж╛ рж╣ржпрж╝рзЗржЫрзЗ!")

# --- ржкрзНрж░рж┐ржорж┐ржпрж╝рж╛ржо рж╕рж╛ржмрж╕рзНржХрзНрж░рж┐ржкрж╢ржирзЗрж░ ржЬржирзНржп ржХржорж╛ржирзНржб ---
@app.on_message(filters.command("premium") & filters.private)
async def premium_info(_, msg: Message):
    user_id = msg.from_user.id
    if is_premium_user(user_id):
        user = users_col.find_one({"_id": user_id})
        expiry_date_str = user['premium_until'].strftime('%Y-%m-%d %H:%M:%S')
        await msg.reply(f"ржЖржкржирж┐ ржПржХржЬржи **ржкрзНрж░рж┐ржорж┐ржпрж╝рж╛ржо рж╕ржжрж╕рзНржп**! ЁЯОЙ\nржЖржкржирж╛рж░ рж╕рж╛ржмрж╕рзНржХрзНрж░рж┐ржкрж╢ржирзЗрж░ ржорзЗржпрж╝рж╛ржж рж╢рзЗрж╖ рж╣ржмрзЗ: **{expiry_date_str} (UTC)**ред")
    else:
        payment_details = f"""
ржЖржорж╛ржжрзЗрж░ **ржкрзНрж░рж┐ржорж┐ржпрж╝рж╛ржо рж╕рж╛ржмрж╕рзНржХрзНрж░рж┐ржкрж╢ржи** ржирж┐ржи ржПржмржВ ржЙржкржнрзЛржЧ ржХрж░рзБржи **ржмрж┐ржЬрзНржЮрж╛ржкржи-ржорзБржХрзНржд ржорзБржнрж┐ рж▓рж┐ржЩрзНржХ**! ЁЯОмтЬи

**ржлрж┐:** рз│100 (ржорж╛рж╕рж┐ржХ)

**ржкрзЗржорзЗржирзНржЯ ржкржжрзНржзрждрж┐:**
1.  **ржмрж┐ржХрж╛рж╢ (Bkash) ржкрж╛рж░рзНрж╕рзЛржирж╛рж▓:** `01XXXXXXXXX` (рж╕рзЗржирзНржб ржорж╛ржирж┐ ржХрж░рзБржи)
2.  **ржиржЧржж (Nagad) ржкрж╛рж░рзНрж╕рзЛржирж╛рж▓:** `01XXXXXXXXX` (рж╕рзЗржирзНржб ржорж╛ржирж┐ ржХрж░рзБржи)

**ржкрзЗржорзЗржирзНржЯ ржХрж░рж╛рж░ ржкрж░:**
ржЯрж╛ржХрж╛ ржкрж╛ржарж╛ржирзЛрж░ ржкрж░, ржЕржирзБржЧрзНрж░рж╣ ржХрж░рзЗ ржкрзЗржорзЗржирзНржЯрзЗрж░ **ржЯрзНрж░рж╛ржирзНрж╕рзЗржХрж╢ржи ржЖржЗржбрж┐ (Transaction ID)** рж╕рж╣ `/paid <ржЯрзНрж░рж╛ржирзНрж╕рзЗржХрж╢ржи_ржЖржЗржбрж┐>` ржПржЗ ржХржорж╛ржирзНржбржЯрж┐ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ ржЖржорж╛ржжрзЗрж░ ржЬрж╛ржирж╛ржиред
ржЙржжрж╛рж╣рж░ржг: `/paid 8P6P5X2A`

ржЖржорж░рж╛ ржжрзНрж░рзБржд ржЖржкржирж╛рж░ ржкрзЗржорзЗржирзНржЯ ржпрж╛ржЪрж╛ржЗ ржХрж░рзЗ ржкрзНрж░рж┐ржорж┐ржпрж╝рж╛ржо рж╕рзНржЯрзНржпрж╛ржЯрж╛рж╕ рж╕ржХрзНрж░рж┐ржпрж╝ ржХрж░рзЗ ржжрзЗржмред ржХрзЛржирзЛ рж╕ржорж╕рзНржпрж╛ рж╣рж▓рзЗ ржЕрзНржпрж╛ржбржорж┐ржирзЗрж░ рж╕рж╛ржерзЗ ржпрзЛржЧрж╛ржпрзЛржЧ ржХрж░рзБржиред
"""
        btns = InlineKeyboardMarkup([
            [InlineKeyboardButton("ржЕрзНржпрж╛ржбржорж┐ржиржХрзЗ ржорзЗрж╕рзЗржЬ ржХрж░рзБржи", url="https://t.me/ctgmovies23")]
        ])
        m = await msg.reply(payment_details, reply_markup=btns)
        asyncio.create_task(delete_message_later(m.chat.id, m.id, delay=1200)) # 20 ржорж┐ржирж┐ржЯ ржкрж░ ржорзЗрж╕рзЗржЬржЯрж┐ ржбрж┐рж▓рж┐ржЯ рж╣ржмрзЗ

# --- ржкрзЗржорзЗржирзНржЯ ржирзЛржЯрж┐ржлрж┐ржХрзЗрж╢ржи рж╣рзНржпрж╛ржирзНржбрзЗрж▓рж┐ржВ (ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзАржжрзЗрж░ ржЬржирзНржп) ---
@app.on_message(filters.command("paid") & filters.private)
async def handle_payment_notification(_, msg: Message):
    if len(msg.command) < 2:
        return await msg.reply("ржЕржирзБржЧрзНрж░рж╣ ржХрж░рзЗ ржЖржкржирж╛рж░ ржЯрзНрж░рж╛ржирзНрж╕рзЗржХрж╢ржи ржЖржЗржбрж┐ ржжрж┐ржиред ржЙржжрж╛рж╣рж░ржг: `/paid 8P6P5X2A`")

    transaction_id = msg.text.split(None, 1)[1].strip()
    user_info = f"ржЗржЙржЬрж╛рж░ `{msg.from_user.id}` `{msg.from_user.first_name}` (`@{msg.from_user.username or 'N/A'}`)"

    notification_message = (
        f"**ЁЯЪи ржирждрзБржи ржкрзЗржорзЗржирзНржЯ ржирзЛржЯрж┐ржлрж┐ржХрзЗрж╢ржи!**\n"
        f"{user_info} ржкрзЗржорзЗржирзНржЯ ржХрж░рзЗржЫрзЗржи ржмрж▓рзЗ ржжрж╛ржмрж┐ ржХрж░ржЫрзЗржиред\n"
        f"**ржЯрзНрж░рж╛ржирзНрж╕рзЗржХрж╢ржи ржЖржЗржбрж┐:** `{transaction_id}`\n\n"
        f"ржпрж╛ржЪрж╛ржЗ ржХрж░рзЗ ржкрзНрж░рж┐ржорж┐ржпрж╝рж╛ржо ржЕрзНржпрж╛ржХрзНрж╕рзЗрж╕ ржжрж┐рждрзЗ ржирж┐ржЪрзЗрж░ ржмрж╛ржЯржиржЯрж┐ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзБржи:"
    )

    for admin_id in ADMIN_IDS:
        try:
            await app.send_message(
                admin_id,
                notification_message,
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("тЬЕ ржкрзНрж░рж┐ржорж┐ржпрж╝рж╛ржо ржжрж┐ржи", callback_data=f"grantpremium_{msg.from_user.id}_{transaction_id}")],
                    [InlineKeyboardButton("тЭМ ржкрзНрж░рждрзНржпрж╛ржЦрзНржпрж╛ржи ржХрж░рзБржи", callback_data=f"rejectpremium_{msg.from_user.id}_{transaction_id}")]
                ])
            )
        except Exception as e:
            print(f"Error sending payment notification to admin {admin_id}: {e}")

    m = await msg.reply("ржЖржкржирж╛рж░ ржкрзЗржорзЗржирзНржЯ ржирзЛржЯрж┐ржлрж┐ржХрзЗрж╢ржи ржЕрзНржпрж╛ржбржорж┐ржиржжрзЗрж░ ржХрж╛ржЫрзЗ ржкрж╛ржарж╛ржирзЛ рж╣ржпрж╝рзЗржЫрзЗред рждрж╛рж░рж╛ ржжрзНрж░рзБржд ржПржЯрж┐ ржпрж╛ржЪрж╛ржЗ ржХрж░рзЗ ржЖржкржирж╛ржХрзЗ ржЬрж╛ржирж╛ржмрзЗред ржзржирзНржпржмрж╛ржж! ЁЯЩП")
    asyncio.create_task(delete_message_later(m.chat.id, m.id, delay=600)) # 10 ржорж┐ржирж┐ржЯ ржкрж░ ржбрж┐рж▓рж┐ржЯ рж╣ржмрзЗ

@app.on_message(filters.text)
async def search(_, msg):
    raw_query = msg.text.strip()
    query = clean_text(raw_query)
    users_col.update_one(
        {"_id": msg.from_user.id},
        {"$set": {"last_search": datetime.utcnow()}},
        upsert=True
    )

    loading = await msg.reply("ЁЯФО рж▓рзЛржб рж╣ржЪрзНржЫрзЗ, ржЕржирзБржЧрзНрж░рж╣ ржХрж░рзЗ ржЕржкрзЗржХрзНрж╖рж╛ ржХрж░рзБржи...")

    suggestions = list(movies_col.find(
        {"title_clean": {"$regex": query}},
        {"title": 1, "message_id": 1, "language": 1}
    ).limit(RESULTS_COUNT))

    if suggestions:
        await loading.delete()
        lang_buttons = [
            InlineKeyboardButton("ржмрж╛ржВрж▓рж╛ ЁЯЗзЁЯЗй", callback_data=f"lang_Bengali_{query}"),
            InlineKeyboardButton("рж╣рж┐ржирзНржжрж┐ ЁЯЗоЁЯЗ│", callback_data=f"lang_Hindi_{query}"),
            InlineKeyboardButton("ржЗржВрж▓рж┐рж╢ ЁЯЗмЁЯЗз", callback_data=f"lang_English_{query}")
        ]
        buttons = [[InlineKeyboardButton(m["title"][:40], callback_data=f"movie_{m['message_id']}")] for m in suggestions]
        buttons.append(lang_buttons)
        m = await msg.reply("ржЖржкржирж╛рж░ ржорзБржнрж┐рж░ ржирж╛ржо ржорж┐рж▓рждрзЗ ржкрж╛рж░рзЗ, ржирж┐ржЪрзЗрж░ ржерзЗржХрзЗ рж╕рж┐рж▓рзЗржХрзНржЯ ржХрж░рзБржи:", reply_markup=InlineKeyboardMarkup(buttons))
        asyncio.create_task(delete_message_later(m.chat.id, m.id, delay=600)) # 10 ржорж┐ржирж┐ржЯ ржкрж░ ржбрж┐рж▓рж┐ржЯ рж╣ржмрзЗ
        return

    await loading.delete()
    Google Search_url = "https://www.google.com/search?q=" + urllib.parse.quote(raw_query)
    google_button = InlineKeyboardMarkup([
        [InlineKeyboardButton("ржЧрзБржЧрж▓рзЗ рж╕рж╛рж░рзНржЪ ржХрж░рзБржи ЁЯФН", url=Google Search_url)]
    ])
    alert = await msg.reply(
        "ржХрзЛржиржУ ржлрж▓рж╛ржлрж▓ ржкрж╛ржУржпрж╝рж╛ ржпрж╛ржпрж╝ржирж┐ред ржЕрзНржпрж╛ржбржорж┐ржиржХрзЗ ржЬрж╛ржирж╛ржирзЛ рж╣ржпрж╝рзЗржЫрзЗред ржирж┐ржЪрзЗрж░ ржмрж╛ржЯржирзЗ ржХрзНрж▓рж┐ржХ ржХрж░рзЗ ржЧрзБржЧрж▓рзЗ рж╕рж╛рж░рзНржЪ ржХрж░рзБржиред",
        reply_markup=google_button
    )
    asyncio.create_task(delete_message_later(alert.chat.id, alert.id, delay=600)) # 10 ржорж┐ржирж┐ржЯ ржкрж░ ржбрж┐рж▓рж┐ржЯ рж╣ржмрзЗ

    btn = InlineKeyboardMarkup([
        [
            InlineKeyboardButton("тЬЕ ржорзБржнрж┐ ржЖржЫрзЗ", callback_data=f"has_{msg.chat.id}_{msg.id}_{raw_query}"),
            InlineKeyboardButton("тЭМ ржирзЗржЗ", callback_data=f"no_{msg.chat.id}_{msg.id}_{raw_query}")
        ],
        [
            InlineKeyboardButton("тП│ ржЖрж╕ржмрзЗ", callback_data=f"soon_{msg.chat.id}_{msg.id}_{raw_query}"),
            InlineKeyboardButton("тЬПя╕П ржнрзБрж▓ ржирж╛ржо", callback_data=f"wrong_{msg.chat.id}_{msg.id}_{raw_query}")
        ]
    ])
    for admin_id in ADMIN_IDS:
        try:
            await app.send_message(
                admin_id,
                f"тЭЧ ржЗржЙржЬрж╛рж░ `{msg.from_user.id}` `{msg.from_user.first_name}` ржЦрзБржБржЬрзЗржЫрзЗ: **{raw_query}**\nржлрж▓рж╛ржлрж▓ ржкрж╛ржУржпрж╝рж╛ ржпрж╛ржпрж╝ржирж┐ред ржирж┐ржЪрзЗ ржмрж╛ржЯржи ржерзЗржХрзЗ ржЙрждрзНрждрж░ ржжрж┐ржиред",
                reply_markup=btn
            )
        except Exception as e:
            print(f"Error sending admin notification to {admin_id}: {e}")

@app.on_callback_query()
async def callback_handler(_, cq: CallbackQuery):
    data = cq.data
    user_id_initiator = cq.from_user.id # ржпрзЗ ржЗржЙржЬрж╛рж░ ржХрж▓ржмрзНржпрж╛ржХ ржХрж░ржЫрзЗржи

    # --- ржкрзНрж░рж┐ржорж┐ржпрж╝рж╛ржо ржЗржиржлрзЛ ржжрзЗржЦрж╛ржирзЛрж░ ржЬржирзНржп ---
    if data == "show_premium_info":
        await cq.answer("ржЖржорж╛ржжрзЗрж░ ржкрзНрж░рж┐ржорж┐ржпрж╝рж╛ржо рж╕рж╛ржмрж╕рзНржХрзНрж░рж┐ржкрж╢ржи рж╕ржорзНржкрж░рзНржХрзЗ рждржерзНржп рж▓рзЛржб рж╣ржЪрзНржЫрзЗ...", show_alert=True)
        # /premium ржХржорж╛ржирзНржбрзЗрж░ рж▓ржЬрж┐ржХржХрзЗ ржХрж▓ ржХрж░рзБржи, ржХрж┐ржирзНрждрзБ ржПржЯрж┐ рж╕рж░рж╛рж╕рж░рж┐ Message ржЕржмржЬрзЗржХрзНржЯ ржкрж╛ржпрж╝ ржирж╛
        # рждрж╛ржЗ, ржПржХржЯрж┐ ржбрж╛ржорж┐ Message ржЕржмржЬрзЗржХрзНржЯ рждрзИрж░рж┐ ржХрж░рзЗ ржкрж╛ржарж╛ржЗ
        dummy_msg = Message(id=0, chat=cq.message.chat, from_user=cq.from_user, date=datetime.utcnow(), text="/premium")
        await premium_info(_, dummy_msg)
        return # ржкрзНрж░рж┐ржорж┐ржпрж╝рж╛ржо ржЗржиржлрзЛ ржжрзЗржЦрж╛ржирзЛрж░ ржкрж░ ржЖрж░ ржХрж┐ржЫрзБ ржХрж░рж╛рж░ ржжрж░ржХрж╛рж░ ржирзЗржЗ

    # --- ржЕрзНржпрж╛ржбржорж┐ржи ржХрж▓ржмрзНржпрж╛ржХ рж╣рзНржпрж╛ржирзНржбрж▓рж╛рж░ (рж╢рзБржзрзБржорж╛рждрзНрж░ ржЕрзНржпрж╛ржбржорж┐ржиржжрзЗрж░ ржЬржирзНржп) ---
    if user_id_initiator in ADMIN_IDS:
        if data.startswith("grantpremium_"):
            _, target_user_id_str, transaction_id = data.split("_", 2)
            target_user_id = int(target_user_id_str)

            premium_expiry = datetime.utcnow() + timedelta(days=30) # 30 ржжрж┐ржирзЗрж░ ржЬржирзНржп ржкрзНрж░рж┐ржорж┐ржпрж╝рж╛ржо
            users_col.update_one(
                {"_id": target_user_id},
                {"$set": {"is_premium": True, "premium_until": premium_expiry}},
                upsert=True
            )

            await cq.message.edit_text(f"тЬЕ ржЗржЙржЬрж╛рж░ `{target_user_id}` ржХрзЗ ржкрзНрж░рж┐ржорж┐ржпрж╝рж╛ржо ржЕрзНржпрж╛ржХрзНрж╕рзЗрж╕ ржжрзЗржУржпрж╝рж╛ рж╣ржпрж╝рзЗржЫрзЗред (ржЯрзНрж░рж╛ржирзНрж╕рзЗржХрж╢ржи: `{transaction_id}`) - ржЕрзНржпрж╛ржбржорж┐ржи: @{cq.from_user.username or cq.from_user.first_name}")
            try:
                await app.send_message(target_user_id, "ржЕржнрж┐ржиржирзНржжржи! ЁЯОЙ ржЖржкржирж╛рж░ ржкрзНрж░рж┐ржорж┐ржпрж╝рж╛ржо рж╕рж╛ржмрж╕рзНржХрзНрж░рж┐ржкрж╢ржи рж╕ржХрзНрж░рж┐ржпрж╝ ржХрж░рж╛ рж╣ржпрж╝рзЗржЫрзЗред ржПржЦржи ржерзЗржХрзЗ ржЖржкржирж┐ рж╕рж░рж╛рж╕рж░рж┐ ржорзБржнрж┐ рж▓рж┐ржЩрзНржХ ржкрж╛ржмрзЗржи ржПржмржВ ржХрзЛржирзЛ ржЕрзНржпрж╛ржб ржжрзЗржЦрж╛ржмрзЗ ржирж╛ред ржЙржкржнрзЛржЧ ржХрж░рзБржи!")
            except Exception as e:
                print(f"Could not send premium activation message to user {target_user_id}: {e}")

            await cq.answer("ржкрзНрж░рж┐ржорж┐ржпрж╝рж╛ржо ржЕрзНржпрж╛ржХрзНрж╕рзЗрж╕ ржжрзЗржУржпрж╝рж╛ рж╣ржпрж╝рзЗржЫрзЗред")
            return # рж╣рзНржпрж╛ржирзНржбрзЗрж▓ рж╣ржпрж╝рзЗ ржЧрзЗрж▓рзЗ ржЖрж░ ржХрж┐ржЫрзБ ржХрж░рж╛рж░ ржжрж░ржХрж╛рж░ ржирзЗржЗ

        elif data.startswith("rejectpremium_"):
            _, target_user_id_str, transaction_id = data.split("_", 2)
            target_user_id = int(target_user_id_str)

            await cq.message.edit_text(f"тЭМ ржЗржЙржЬрж╛рж░ `{target_user_id}` ржПрж░ ржкрзЗржорзЗржирзНржЯ ржкрзНрж░рждрзНржпрж╛ржЦрзНржпрж╛ржи ржХрж░рж╛ рж╣ржпрж╝рзЗржЫрзЗред (ржЯрзНрж░рж╛ржирзНрж╕рзЗржХрж╢ржи: `{transaction_id}`) - ржЕрзНржпрж╛ржбржорж┐ржи: @{cq.from_user.username or cq.from_user.first_name}")
            try:
                await app.send_message(target_user_id, "ржжрзБржГржЦрж┐ржд! ЁЯШЯ ржЖржкржирж╛рж░ ржкрзЗржорзЗржирзНржЯ ржпрж╛ржЪрж╛ржЗ ржХрж░рж╛ ржпрж╛ржпрж╝ржирж┐ред ржЕржирзБржЧрзНрж░рж╣ ржХрж░рзЗ рж╕ржарж┐ржХ ржЯрзНрж░рж╛ржирзНрж╕рзЗржХрж╢ржи ржЖржЗржбрж┐ ржжрж┐ржпрж╝рзЗ ржЖржмрж╛рж░ ржЪрзЗрж╖рзНржЯрж╛ ржХрж░рзБржи ржЕржержмрж╛ ржЕрзНржпрж╛ржбржорж┐ржирзЗрж░ рж╕рж╛ржерзЗ ржпрзЛржЧрж╛ржпрзЛржЧ ржХрж░рзБржиред")
            except Exception as e:
                print(f"Could not send premium rejection message to user {target_user_id}: {e}")

            await cq.answer("ржкрзЗржорзЗржирзНржЯ ржкрзНрж░рждрзНржпрж╛ржЦрзНржпрж╛ржи ржХрж░рж╛ рж╣ржпрж╝рзЗржЫрзЗред")
            return # рж╣рзНржпрж╛ржирзНржбрзЗрж▓ рж╣ржпрж╝рзЗ ржЧрзЗрж▓рзЗ ржЖрж░ ржХрж┐ржЫрзБ ржХрж░рж╛рж░ ржжрж░ржХрж╛рж░ ржирзЗржЗ

        elif "_" in data and len(data.split("_")) == 4: # ржЗржЙржЬрж╛рж░ рж╕рж╛рж░рзНржЪ рж░рж┐ржХрзЛржпрж╝рзЗрж╕рзНржЯрзЗрж░ ржЕрзНржпрж╛ржбржорж┐ржи рж░рзЗрж╕ржкржирзНрж╕
            parts = data.split("_", 3)
            action, uid, mid, raw_query = parts
            uid = int(uid)
            responses = {
                "has": f"тЬЕ @{cq.from_user.username or cq.from_user.first_name} ржЬрж╛ржирж┐ржпрж╝рзЗржЫрзЗржи ржпрзЗ **{raw_query}** ржорзБржнрж┐ржЯрж┐ ржбрж╛ржЯрж╛ржмрзЗржЬрзЗ ржЖржЫрзЗред рж╕ржарж┐ржХ ржирж╛ржо рж▓рж┐ржЦрзЗ ржЖржмрж╛рж░ ржЪрзЗрж╖рзНржЯрж╛ ржХрж░рзБржиред",
                "no": f"тЭМ @{cq.from_user.username or cq.from_user.first_name} ржЬрж╛ржирж┐ржпрж╝рзЗржЫрзЗржи ржпрзЗ **{raw_query}** ржорзБржнрж┐ржЯрж┐ ржбрж╛ржЯрж╛ржмрзЗржЬрзЗ ржирзЗржЗред",
                "soon": f"тП│ @{cq.from_user.username or cq.from_user.first_name} ржЬрж╛ржирж┐ржпрж╝рзЗржЫрзЗржи ржпрзЗ **{raw_query}** ржорзБржнрж┐ржЯрж┐ рж╢рзАржШрзНрж░ржЗ ржЖрж╕ржмрзЗред",
                "wrong": f"тЬПя╕П @{cq.from_user.username or cq.from_user.first_name} ржмрж▓ржЫрзЗржи ржпрзЗ ржЖржкржирж┐ ржнрзБрж▓ ржирж╛ржо рж▓рж┐ржЦрзЗржЫрзЗржи: **{raw_query}**ред"
            }
            if action in responses:
                m = await app.send_message(uid, responses[action])
                asyncio.create_task(delete_message_later(m.chat.id, m.id))
                await cq.answer("ржЕрзНржпрж╛ржбржорж┐ржирзЗрж░ ржкржХрзНрж╖ ржерзЗржХрзЗ ржЙрждрзНрждрж░ ржкрж╛ржарж╛ржирзЛ рж╣ржпрж╝рзЗржЫрзЗред")
            else:
                await cq.answer()
            return # рж╣рзНржпрж╛ржирзНржбрзЗрж▓ рж╣ржпрж╝рзЗ ржЧрзЗрж▓рзЗ ржЖрж░ ржХрж┐ржЫрзБ ржХрж░рж╛рж░ ржжрж░ржХрж╛рж░ ржирзЗржЗ

    # --- ржорзБржнрж┐ ржбрзЗрж▓рж┐ржнрж╛рж░рж┐ рж▓ржЬрж┐ржХ (рж╕ржм ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзАрж░ ржЬржирзНржп) ---
    if data.startswith("movie_"):
        mid = int(data.split("_")[1])

        if is_premium_user(user_id_initiator):
            # ржкрзНрж░рж┐ржорж┐ржпрж╝рж╛ржо ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзА рж╣рж▓рзЗ рж╕рж░рж╛рж╕рж░рж┐ ржорзБржнрж┐ ржлрж░ржУржпрж╝рж╛рж░рзНржб ржХрж░рзБржи, рж▓рж┐ржЩрзНржХ рж╢рж░рзНржЯржирж╛рж░ ржЫрж╛ржбрж╝рж╛ржЗ
            fwd = await app.forward_messages(cq.message.chat.id, CHANNEL_ID, mid)
            asyncio.create_task(delete_message_later(cq.message.chat.id, fwd.id, delay=1800)) # 30 ржорж┐ржирж┐ржЯ ржкрж░ ржбрж┐рж▓рж┐ржЯ рж╣ржмрзЗ
            await cq.answer("ржЖржкржирж╛рж░ ржкрзНрж░рж┐ржорж┐ржпрж╝рж╛ржо ржорзБржнрж┐ ржкрж╛ржарж╛ржирзЛ рж╣ржпрж╝рзЗржЫрзЗред", show_alert=True)
        else:
            # рж╕рж╛ржзрж╛рж░ржг ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзА рж╣рж▓рзЗ рж▓рж┐ржЩрзНржХ рж╢рж░рзНржЯржирж╛рж░ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзБржи
            try:
                movie_message = await app.get_messages(CHANNEL_ID, mid)
                original_text = movie_message.text or movie_message.caption
                movie_link_pattern = r"https?://\S+" # рж▓рж┐ржЩрзНржХрзЗрж░ ржкрзНржпрж╛ржЯрж╛рж░рзНржи
                found_links = re.findall(movie_link_pattern, original_text)

                modified_text = original_text
                # рж▓рж┐ржЩрзНржХ рж╢рж░рзНржЯржирж╛рж░ ржкрзНрж░ржпрж╝рзЛржЧ ржХрж░рзБржи
                for link in found_links:
                    short_link = shorten_link(link)
                    modified_text = modified_text.replace(link, short_link)

                # рж▓рж┐ржЩрзНржХ рж╢рж░рзНржЯ ржХрж░рж╛рж░ ржкрж░ ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзАржХрзЗ ржирждрзБржи ржорзЗрж╕рзЗржЬ ржкрж╛ржарж╛ржи
                m = await cq.message.reply_text(
                    f"ржЖржкржирж╛рж░ ржорзБржнрж┐ рж▓рж┐ржЩрзНржХ:\n\n{modified_text}\n\n**ржЯрж┐ржкрж╕:** ржмрж┐ржЬрзНржЮрж╛ржкржи ржЫрж╛ржбрж╝рж╛ рж╕рж░рж╛рж╕рж░рж┐ ржорзБржнрж┐ ржкрзЗрждрзЗ ржЖржорж╛ржжрзЗрж░ **ржкрзНрж░рж┐ржорж┐ржпрж╝рж╛ржо рж╕рж╛ржмрж╕рзНржХрзНрж░рж┐ржкрж╢ржи** ржирж┐ржи! ЁЯСЗ",
                    reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("ржкрзНрж░рж┐ржорж┐ржпрж╝рж╛ржо ржирж┐ржи", callback_data="show_premium_info")]])
                )
                asyncio.create_task(delete_message_later(m.chat.id, m.id, delay=900)) # 15 ржорж┐ржирж┐ржЯ ржкрж░ ржбрж┐рж▓рж┐ржЯ рж╣ржмрзЗ

                await cq.answer("ржорзБржнрж┐ рж▓рж┐ржЩрзНржХ ржкрж╛ржарж╛ржирзЛ рж╣ржпрж╝рзЗржЫрзЗред")

            except Exception as e:
                await cq.answer("ржорзБржнрж┐ рж▓рзЛржб ржХрж░рждрзЗ рж╕ржорж╕рзНржпрж╛ рж╣ржпрж╝рзЗржЫрзЗред ржЕрзНржпрж╛ржбржорж┐ржиржХрзЗ ржЬрж╛ржирж╛ржирзЛ рж╣ржпрж╝рзЗржЫрзЗред", show_alert=True)
                print(f"Error processing movie callback for non-premium user: {e}")

    elif data.startswith("lang_"):
        _, lang, query = data.split("_", 2)
        lang_movies = list(movies_col.find({"language": lang}))
        matches = [
            m for m in lang_movies
            if re.search(re.escape(query), clean_text(m.get("title", "")), re.IGNORECASE)
        ]
        if matches:
            buttons = [
                [InlineKeyboardButton(m["title"][:40], callback_data=f"movie_{m['message_id']}")]
                for m in matches[:RESULTS_COUNT]
            ]
            await cq.message.edit_text(
                f"ржлрж▓рж╛ржлрж▓ ({lang}) - ржирж┐ржЪрзЗрж░ ржерзЗржХрзЗ рж╕рж┐рж▓рзЗржХрзНржЯ ржХрж░рзБржи:",
                reply_markup=InlineKeyboardMarkup(buttons)
            )
        else:
            await cq.answer(f"ржПржЗ ржнрж╛рж╖рж╛ржпрж╝ '{query}' ржПрж░ ржЬржирзНржп ржХрж┐ржЫрзБ ржкрж╛ржУржпрж╝рж╛ ржпрж╛ржпрж╝ржирж┐ред", show_alert=True)
        await cq.answer() # ржХрж▓ржмрзНржпрж╛ржХ рж╢рзЗрж╖ ржХрж░рж╛


if __name__ == "__main__":
    print("ржмржЯ рж╢рзБрж░рзБ рж╣ржЪрзНржЫрзЗ...")
    app.run()

